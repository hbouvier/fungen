package main

import (
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"strings"
)

var (
	packageName = flag.String("package", "main", "(Optional) Name of the package.")
	types       = flag.String("types", "", "Comma-separated list of type names, eg. 'int,string,CustomType'. The values can themselves be colon (:) separated to specify the names of entities in the generated, eg: int:I,string:Str,CustomType:CT.")
	testrun     = flag.Bool("test", false, "whether to display the generated code instead of writing out to a file.")
)

func usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tgen -package packageName -types Types\n")
	fmt.Fprintf(os.Stderr, "Example:\n")
	fmt.Fprintf(os.Stderr, "'gen -package mypackage -types string,int,customType,AnotherType' will create types 'stringList []string, intList []int, customTypeList []customType, AnotherTypeList []AnotherType' with the Map, Filter, Reduce, ReduceRight, Take, TakeWhile, Drop, DropWhile, Each, EachI methods on them. Additionally, methods named MapType1Type2 will be generated on these types for the remaining types. The package of the generated file will be 'mypackage' \n\n")
	fmt.Fprintf(os.Stderr, "'gen -types string,int:I,customType:CT,AnotherType:At' will create types 'stringList []string, IList []int, CTList []customType, AtList []AnotherType'. The 'stringList' type will have the Map, Filter, Reduce, ReduceRight, Take, TakeWhile, Drop, DropWhile, Each, EachI methods on it. Additionally, it will also have MapI, MapCt and MapAt methods. The package of the generated file will be 'main' \n\n")

	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	flag.Usage = usage
	flag.Parse()

	if len(*types) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	dir := ""
	src := ""
	outputName := ""

	typeMap := getTypeMap(*types)

	for k1, v1 := range typeMap {
		filename := getFileNameForTypes(k1, typeMap)
		baseName := fmt.Sprintf("fungen_%[1]s.go", filename)
		outputName := getFileName(dir, outputName, baseName)

		src = generate(*packageName, k1, v1+"List", typeMap)
		//fmt.Println(src)
		src = f(src)

		if *testrun {
			fmt.Println(outputName)
			fmt.Println(src)
		} else {
			err := ioutil.WriteFile(outputName, []byte(src), 0644)
			if err != nil {
				log.Fatalf("writing output: %s", err)
			}
		}
	}

}

func f(s string) string {
	formatted, err := format.Source([]byte(s))
	if err != nil {
		log.Fatal(err)
	}
	return string(formatted)
}

func getFileNameForTypes(t string, m map[string]string) string {
	if len(m) == 0 {
		return t
	}
	s := t
	for k, v := range m {
		if t == k {
			continue
		}
		s += "_" + v
	}
	return s
}

func getTypeMap(targets string) map[string]string {
	m := map[string]string{}
	if targets == "" {
		return m
	}

	targetParts := strings.Split(targets, ",")
	for _, t := range targetParts {
		tParts := strings.Split(t, ":")
		if len(tParts) == 1 {
			m[tParts[0]] = tParts[0]
		} else {
			m[tParts[0]] = tParts[1]
		}
	}

	return m
}

func getFileName(dir, outputName, baseName string) string {
	if outputName == "" {
		return strings.ToLower(baseName)
	}
	return strings.ToLower(outputName)
}

func generate(packageName, typeName, listname string, m map[string]string) string {
	if packageName == "" {
		packageName = "main"
	}

	code := ""
	code = fmt.Sprintf(`// generated by fungen; DO NOT EDIT
            package %[1]s
            
            import "sync"
            
            // %[3]s is the type for a list that holds members of type %[2]s
            type %[3]s []%[2]s
            `, packageName, typeName, listname)

	for k, v := range m {
		if k == typeName {
			code += getMapFunction(listname, typeName, k, "")
			code += getPMapFunction(listname, typeName, k, "")
		} else {
			code += getMapFunction(listname, typeName, k, v)
			code += getPMapFunction(listname, typeName, k, v)
		}

	}

	code += getFilterFunction(listname, typeName)
	code += getPFilterFunction(listname, typeName)
	code += getReduceFunction(listname, typeName)
	code += getReduceRightFunction(listname, typeName)
	code += getTakeFunction(listname, typeName)
	code += getTakeWhileFunction(listname, typeName)
	code += getDropFunction(listname, typeName)
	code += getDropWhileFunction(listname, typeName)
	code += getEachFunction(listname, typeName)
	code += getEachIFunction(listname, typeName)

	return code
}

func getMapFunction(listName, typeName, targetType, targetTypeName string) string {
	if targetTypeName == "" {
		return fmt.Sprintf(`
            // Map%[4]s is a method on %[1]s that takes a function of type %[2]s -> %[3]s and applies it to every member of %[1]s
            func (l %[1]s) Map%[4]s(f func(%[2]s) %[3]s) %[1]s {
                l2 := make(%[1]s, len(l))
                for i, t := range l {
                    l2[i] = f(t)
                }
                return l2
            }
            `, listName, typeName, targetType, targetTypeName)
	}

	return fmt.Sprintf(`
        // Map%[4]s is a method on %[1]s that takes a function of type %[2]s -> %[3]s and applies it to every member of %[1]s
        func (l %[1]s) Map%[4]s(f func(%[2]s) %[3]s) %[5]sList {
            l2 := make(%[5]sList, len(l))
            for i, t := range l {
                l2[i] = f(t)
            }
            return l2
        }
        `, listName, typeName, targetType, strings.Title(targetTypeName), targetTypeName)

}

func getPMapFunction(listName, typeName, targetType, targetTypeName string) string {
	if targetTypeName == "" {
		return fmt.Sprintf(`
            // PMap%[4]s is similar to Map%[4]s except that it applies the function on each member in parallel.
            func (l %[1]s) PMap%[4]s(f func(%[2]s) %[3]s) %[1]s {
                wg := sync.WaitGroup{}
                l2 := make(%[1]s, len(l))
                for i, t := range l {
                    wg.Add(1)
                    go func(i int, t %[2]s){
                        l2[i] = f(t)
                        wg.Done()
                    }(i, t)
                }
                wg.Wait()
                return l2
            }
            `, listName, typeName, targetType, targetTypeName)
	}

	return fmt.Sprintf(`
        // PMap%[4]s is similar to Map%[4]s except that it executes the function on each member in parallel.
        func (l %[1]s) PMap%[4]s(f func(%[2]s) %[3]s) %[5]sList {
            wg := sync.WaitGroup{}
            l2 := make(%[5]sList, len(l))
            for i, t := range l {
                wg.Add(1)
                go func(i int, t %[2]s){
                    l2[i] = f(t)
                    wg.Done()
                }(i, t)
            }
            wg.Wait()
            return l2
        }
        `, listName, typeName, targetType, strings.Title(targetTypeName), targetTypeName)

}

func getFilterFunction(listName, typeName string) string {
	return fmt.Sprintf(`
        // Filter is a method on %[1]s that takes a function of type %[2]s -> bool returns a list of type %[1]s which contains all members from the original list for which the function returned true
        func (l %[1]s) Filter(f func(%[2]s) bool) %[1]s {
            l2 := []%[2]s{}
            for _, t := range l {
                if f(t) {
                    l2 = append(l2, t)
                }
            }
            return l2
        }
        `, listName, typeName)
}

func getPFilterFunction(listName, typeName string) string {
	return fmt.Sprintf(`
        // PFilter is similar to the Filter method except that the filter is applied to all the elements in parallel. The order of resulting elements cannot be guaranteed. 
        func (l %[1]s) PFilter(f func(%[2]s) bool) %[1]s {
            wg := sync.WaitGroup{}
            mutex := sync.Mutex{}
            l2 := []%[2]s{}
            for _, t := range l {
                wg.Add(1)
                go func(t %[2]s){
                    if f(t) {
                        mutex.Lock()
                        l2 = append(l2, t)
                        mutex.Unlock()
                    }            
                    wg.Done()
                }(t)
            }
            wg.Wait()
            return l2
        }
        `, listName, typeName)
}

func getEachFunction(listName, typeName string) string {
	return fmt.Sprintf(`
        // Each is a method on %[1]s that takes a function of type %[2]s -> void and applies the function to each member of the list and then returns the original list.
        func (l %[1]s) Each(f func(%[2]s)) %[1]s {
            for _, t := range l {
                f(t) 
            }
            return l
        }
        `, listName, typeName)
}

func getEachIFunction(listName, typeName string) string {
	return fmt.Sprintf(`
        // EachI is a method on %[1]s that takes a function of type (int, %[2]s) -> void and applies the function to each member of the list and then returns the original list. The int parameter to the function is the index of the element.
        func (l %[1]s) EachI(f func(int, %[2]s)) %[1]s {
            for i, t := range l {
                f(i, t) 
            }
            return l
        }
        `, listName, typeName)
}

func getDropWhileFunction(listName, typeName string) string {
	return fmt.Sprintf(`
        // DropWhile is a method on %[1]s that takes a function of type %[2]s -> bool and returns a list of type %[1]s which excludes the first members from the original list for which the function returned true
        func (l %[1]s) DropWhile(f func(%[2]s) bool) %[1]s {
            for i, t := range l {
                if !f(t) {
                    return l[i:]
                }
            }
            var l2 %[1]s
            return l2
        }
        `, listName, typeName)
}

func getTakeWhileFunction(listName, typeName string) string {
	return fmt.Sprintf(`
        // TakeWhile is a method on %[1]s that takes a function of type %[2]s -> bool and returns a list of type %[1]s which includes only the first members from the original list for which the function returned true
        func (l %[1]s) TakeWhile(f func(%[2]s) bool) %[1]s {
            for i, t := range l {
                if !f(t) {
                    return l[:i]
                }
            }
            return l
        }
        `, listName, typeName)
}

func getTakeFunction(listName, typeName string) string {
	return fmt.Sprintf(`
        // Take is a method on %[1]s that takes an integer n and returns the first n elements of the original list. If the list contains fewer than n elements then the entire list is returned.
        func (l %[1]s) Take(n int) %[1]s {
            if len(l) >= n {
                return l[:n]
            }
            return l
        }
        `, listName, typeName)
}

func getDropFunction(listName, typeName string) string {
	return fmt.Sprintf(`
        // Drop is a method on %[1]s that takes an integer n and returns all but the first n elements of the original list. If the list contains fewer than n elements then an empty list is returned.
        func (l %[1]s) Drop(n int) %[1]s {
            if len(l) >= n {
                return l[n:]
            }
            var l2 %[1]s
            return l2
        }
        `, listName, typeName)
}

func getReduceFunction(listName, typename string) string {
	return fmt.Sprintf(`
        // Reduce is a method on %[1]s that takes a function of type (%[2]s, %[2]s) -> %[2]s and returns a %[2]s which is the result of applying the function to all members of the original list starting from the first member
        func (l %[1]s) Reduce(t1 %[2]s, f func(%[2]s, %[2]s) %[2]s) %[2]s {
            for _, t := range l {
                t1 = f(t1, t)
            }
            return t1
        }
        `, listName, typename)
}

func getReduceRightFunction(listName, typename string) string {
	return fmt.Sprintf(`
        // ReduceRight is a method on %[1]s that takes a function of type (%[2]s, %[2]s) -> %[2]s and returns a %[2]s which is the result of applying the function to all members of the original list starting from the last member
        func (l %[1]s) ReduceRight(t1 %[2]s, f func(%[2]s, %[2]s) %[2]s) %[2]s {
            for i := len(l) - 1; i >= 0; i-- {
                t := l[i]
                t1 = f(t, t1)
            }
            return t1
        }
        `, listName, typename)
}
